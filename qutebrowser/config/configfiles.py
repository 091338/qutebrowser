# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:

# Copyright 2014-2017 Florian Bruhin (The Compiler) <mail@qutebrowser.org>
#
# This file is part of qutebrowser.
#
# qutebrowser is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# qutebrowser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.

"""Configuration files residing on disk."""

import types
import os.path
import textwrap
import configparser

from PyQt5.QtCore import QSettings

from qutebrowser.utils import objreg, standarddir, utils, qtutils


class StateConfig(configparser.ConfigParser):

    """The "state" file saving various application state."""

    def __init__(self):
        super().__init__()
        save_manager = objreg.get('save-manager')
        self._filename = os.path.join(standarddir.data(), 'state')
        self.read(self._filename, encoding='utf-8')
        for sect in ['general', 'geometry']:
            try:
                self.add_section(sect)
            except configparser.DuplicateSectionError:
                pass
        # See commit a98060e020a4ba83b663813a4b9404edb47f28ad.
        self['general'].pop('fooled', None)
        save_manager.add_saveable('state-config', self._save)

    def _save(self):
        """Save the state file to the configured location."""
        with open(self._filename, 'w', encoding='utf-8') as f:
            self.write(f)


class YamlConfig:

    """A config stored on disk as YAML file.

    Class attributes:
        VERSION: The current version number of the config file.
    """

    VERSION = 1

    def __init__(self):
        save_manager = objreg.get('save-manager')
        self._filename = os.path.join(standarddir.config(auto=True),
                                      'autoconfig.yml')
        save_manager.add_saveable('yaml-config', self._save)
        self.values = {}

    def _save(self):
        """Save the changed settings to the YAML file."""
        data = {'config_version': self.VERSION, 'global': self.values}
        with qtutils.savefile_open(self._filename) as f:
            f.write(textwrap.dedent("""
                # DO NOT edit this file by hand, qutebrowser will overwrite it.
                # Instead, create a config.py - see :help for details.

            """.lstrip('\n')))
            utils.yaml_dump(data, f)

    def load(self):
        """Load self.values from the configured YAML file."""
        # FIXME:conf error handling
        try:
            with open(self._filename, 'r', encoding='utf-8') as f:
                self.values = utils.yaml_load(f)['global']
        except FileNotFoundError:
            pass


class ConfigAPI:

    """Object which gets passed to config.py as "config" object.

    This is a small wrapper over the Config object, but with more
    straightforward method names (get/set call get_obj/set_obj) and a more
    shallow API.

    Attributes:
        _config: The main Config object to use.
        _keyconfig: The KeyConfig object.
        val: A matching ConfigContainer object.
        load_autoconfig: Whether autoconfig.yml should be loaded.
    """

    def __init__(self, config, keyconfig, container):
        self._config = config
        self._keyconfig = keyconfig
        self.val = container
        self.load_autoconfig = True

    def get(self, name):
        return self._config.get_obj(name)

    def set(self, name, value):
        self._config.set_obj(name, value)

    def bind(self, key, command, *, mode, force=False):
        self._keyconfig.bind(key, command, mode=mode, force=force)

    def unbind(self, key, *, mode):
        self._keyconfig.unbind(key, mode=mode)


def read_config_py(filename=None):
    """Read a config.py file."""
    from qutebrowser.config import config
    # FIXME:conf error handling
    if filename is None:
        filename = os.path.join(standarddir.config(), 'config.py')
        if not os.path.exists(filename):
            return None

    api = ConfigAPI(config.instance, config.key_instance, config.val)
    module = types.ModuleType('config')
    module.config = api
    module.c = api.val
    module.__file__ = filename

    with open(filename, mode='rb') as f:
        source = f.read()
    code = compile(source, filename, 'exec')
    exec(code, module.__dict__)

    return api


def init(config):
    """Initialize config storage not related to the main config."""
    state = StateConfig()
    objreg.register('state-config', state)

    # We need to import this here because lineparser needs config.
    # FIXME:conf add this to the Command widget or something?
    from qutebrowser.misc import lineparser
    save_manager = objreg.get('save-manager')
    command_history = lineparser.LimitLineParser(
        standarddir.data(), 'cmd-history',
        limit='completion.cmd_history_max_items',
        parent=config)
    objreg.register('command-history', command_history)
    save_manager.add_saveable('command-history', command_history.save,
                              command_history.changed)

    # Set the QSettings path to something like
    # ~/.config/qutebrowser/qsettings/qutebrowser/qutebrowser.conf so it
    # doesn't overwrite our config.
    #
    # This fixes one of the corruption issues here:
    # https://github.com/qutebrowser/qutebrowser/issues/515

    path = os.path.join(standarddir.config(auto=True), 'qsettings')
    for fmt in [QSettings.NativeFormat, QSettings.IniFormat]:
        QSettings.setPath(fmt, QSettings.UserScope, path)
